# 解题思路
**动态规划思想是希望连续的，也就是说上一个状态和下一个状态(自变量)之间有关系而且连续。**

**动态规划：dp[i]，表示的是爬到第 i 阶楼梯，共有 dp[i] 种方法数。**

每次要找到爬上 i - 1 阶楼梯的方法数和爬上 i - 2 阶楼梯的方法数，当计算 i 阶时，直接利用 i - 1 阶的方法数和 i - 2 阶的方法数来进行计算。因为当为 i - 1 阶时，再爬 1 阶就到第 i 阶了。当为 i - 2 阶时，再爬 2 阶就到第 i 阶了(**有人可能会问：dp[i-2] 再一步跳两个台阶，我选择一个走一个台阶不一样到 dp[i] 吗？** `此时，如果变成一步走一个台阶的话，就回到了第一种情况了，先算到 i - 1 阶，再走最后一步`)。

`状态转移方程：dp[i] = dp[i - 1] + dp[i - 2]`

初始化：一次只能爬一个或两个阶梯
- **dp[0] = 0**：假设有第 0 层阶梯，但每次只能爬一个或两个阶梯，所以上到第 0 层的方法数为 0。
- **dp[1] = 1**：上到第 1 层阶梯的方法数只有一种(1 阶)。
- **dp[2] = 2**：上到第 2 层阶梯的方法数有两种(1 阶 + 1 阶 / 2阶)。

因为直接操作了 dp[1] 和 dp[2]，所以要在开始时先对 n 进行判断：若 n <= 1，则直接返回 1；若 n > 1，则继续执行。否则，在执行到 dp[1] = 1 或 dp[2] = 2 时可能会出现数组下标越界的错误。

循环中 i 直接从 3 开始，可以根据 dp[1] 和 dp[2] 直接得到 dp[3] 的值，即为爬到 3 层阶梯的方法数。

---
# 代码

```java
class Solution {

    public int climbStairs(int n) {

        int[] dp = new int[n + 1];
        if (n <= 1) return 1;
        dp[0] = 0;
        dp[1] = 1;
        dp[2] = 2;
        for (int i=3;i<=n;i++) {

            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
```
时间复杂度：O(n)
空间复杂度：O(n)